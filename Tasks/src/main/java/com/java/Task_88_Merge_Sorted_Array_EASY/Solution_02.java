package com.java.Task_88_Merge_Sorted_Array_EASY;

/**
 * Подход 2:
 * Слияние двух отсортированных массивов через копирование элементов
 * Этот подход предполагает создание нового массива, куда добавляются элементы из обоих исходных массивов,
 * поддерживая порядок сортировки.
 * После того как новый массив заполнен, можно его скопировать его обратно в nums1.
 * Этот метод имеет сложность O(m+n), но требует дополнительного места под временный массив.
 * Сложность O(m+n) означает, что время выполнения алгоритма линейно зависит от суммы размеров двух наборов данных m и n.
 * Это означает, что увеличение любого из этих параметров приведет к пропорциональному увеличению времени выполнения алгоритма.
 * Такая сложность характерна для алгоритмов, которые последовательно обрабатывают элементы обоих наборов данных.
 * Например, если у вас есть два списка длиной m и n соответственно, и вам нужно выполнить операцию над каждым элементом
 * каждого списка, то общая сложность будет O(m+n).
 */
class Solution_02 {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // Создаем временный массив для хранения результата
        int[] temp = new int[m + n];

        // Индексы для прохода по обоим массивам
        int i = 0, j = 0, k = 0;

        // Заполняем временный массив элементами из nums1 и nums2
        while (i < m && j < n) {
            if (nums1[i] < nums2[j]) {
                temp[k++] = nums1[i++];
            } else {
                temp[k++] = nums2[j++];
            }
        }

        // Добавляем оставшиеся элементы из nums1, если такие остались
        while (i < m) {
            temp[k++] = nums1[i++];
        }

        // Добавляем оставшиеся элементы из nums2, если такие остались
        while (j < n) {
            temp[k++] = nums2[j++];
        }

        // Копируем результат обратно в nums1
        for (k = 0; k < m + n; ++k) {
            nums1[k] = temp[k];
        }
    }
}