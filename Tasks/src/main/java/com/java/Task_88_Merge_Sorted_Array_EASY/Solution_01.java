package com.java.Task_88_Merge_Sorted_Array_EASY;

/**
 * Подход 1:
 * Слияние двух отсортированных массивов без использования временного массива:
 * Мы можем избежать создания временного массива, если будем вставлять элементы прямо в nums1, начиная с конца.
 * Этот алгоритм работает за O(m+n) времени и использует только константную дополнительную память.
 */
class Solution_01 {

    /**
     * Метод для слияния двух отсортированных массивов nums1 и nums2.
     * @param nums1 Первый массив, в котором необходимо сохранить результат объединения.
     *              Первые m элементов содержат действительные значения, остальные являются резервными.
     * @param m Количество действительных элементов в массиве nums1.
     * @param nums2 Второй массив, содержащий n отсортированных элементов.
     * @param n Количество действительных элементов в массиве nums2.
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // Начнем с конца массива nums1
        // Индексирование (индексы для прохода по массивам):
        int i = m - 1; // i — индекс последнего действительного элемента в массиве nums1
        int j = n - 1; // j — индекс последнего элемента в массиве nums2
        int k = m + n - 1; /* k — начальный индекс для записи результата в массив nums1, начиная с конца.
                            Поскольку длина объединенного массива равна m + n,
                            то последняя позиция будет иметь индекс m + n - 1. */

        // Заполняем nums1 от конца к началу:
        // Сравниваем элементы из концов массивов nums1 и nums2:
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) { // если элемент из nums1 больше, текущего элемента из nums2, то
                // этот элемент из nums1 записывается в массив nums1 на позицию k,
                nums1[k--] = nums1[i--]; //
                // после чего уменьшаем индексы k и i
            } else { // Иначе,
                // если элемент из nums2 больше или равен текущему элементу из nums1,
                nums1[k--] = nums2[j--]; // то записываем элемент из nums2 в массив nums1 на позицию k,
                // уменьшая индексы k и j.
            }
        }

        /*Проверка оставшихся элементов в nums2:
        Если остались элементы в nums2, переносим их в начало nums1,
        т.к. все оставшиеся элементы nums1 были уже перенесены в конец.
         */
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
}