package com.java.Complication_3_Hard.Task_2290_Minimum_Obstacle_Removal_to_Reach_Corner;

import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * Класс для реализации поиска кратчайшего пути с использованием алгоритма Dijkstra,
 * модифицированного под задачу минимизации препятствий.
 */
class Solution {

    // Массив DIRECTIONS никогда не изменяется, поэтому его объявлено как final, чтобы подчеркнуть неизменность данных.
    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // массив направлений движения
    // (вправо, вниз, влево, вверх)

    public int minimumObstacles(int[][] grid) {

        // Инициализация переменных:
        int m = grid.length; // количество строк в сетке
        int n = grid[0].length; // количество столбцов в сетке
        int[][] minObstacles = new int[m][n]; // массив для хранения минимального количества препятствий до каждой клетки

        // Заполнение массива minObstacles значениями Integer.MAX_VALUE, что означает бесконечность.:
        for (int[] row : minObstacles) {
            Arrays.fill(row, Integer.MAX_VALUE); // т.к. изначально неизвестно, сколько препятствий нужно пройти до любой ячейки.
        }

        minObstacles[0][0] = 0; // Начальная точка имеет 0 препятствий

        /*
            Осуществление приоритезация в очереди на основе количества препятствий (obstacles),
            поэтому a[2] - b[2], а не a[1] - b[1], и не a[0] - b[0]

                Первая компонента (a[0]) — это координата x текущей клетки.
                Вторая компонента (a[1]) — это координата y текущей клетки.
                Третья компонента (a[2]) — это количество препятствий, пройденных до этой клетки.

            Координаты x и y (первые две компоненты массива) не используются для сравнения,
            потому что наша цель — минимизировать количество препятствий, а не расстояние между клетками.

            Координаты нужны лишь для определения местоположения клетки в сетке,
            но не влияют на порядок извлечения элементов из очереди.
         */
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        // PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[2])); // import java.util.Comparator;
        pq.offer(new int[]{0, 0, 0}); // {x, y, obstacles}
        // Добавляем начальную точку (0, 0) с нулевыми препятствиями

        // Основная логика поиска кратчайшего пути:
        while (!pq.isEmpty()) { // Пока очередь не пустая,
            int[] current = pq.poll(); // Метод poll() извлекает текущую позицию из очереди (элемент с наименьшими препятствиями),
            int x = current[0]; // после чего мы разбираем его на координаты x и y
            int y = current[1];
            int obstacles = current[2]; // а также количество препятствий obstacles.
            // int x = current[0], y = current[1], obstacles = current[2];

            // Проверка достижения цели (нижней правой клетки):
            if (x == m - 1 && y == n - 1) { // Если текущие координаты совпадают с нижним правым углом сетки (координатами (m - 1, n - 1)),
                // то это значит, что мы нашли путь к цели.
                return obstacles; // Возвращается текущее количество препятствий, необходимое для прохождения этого пути.
            }

            // Обход соседних клеток:
            for (int[] dir : DIRECTIONS) { // Мы проходим по всем направлениям (вправо, вниз, влево, вверх), используя массив directions.
                // Для каждого направления вычисляются новые координаты newX и newY:
                int newX = x + dir[0];
                int newY = y + dir[1];

                // Проверяем, находятся ли эти координаты внутри сетки (не выходят ли за её границы):
                if (newX >= 0 && newX < m && newY >= 0 && newY < n) {
                    // Если да, вычисляем новое количество препятствий:
                    int newObstacles = obstacles + grid[newX][newY]; // суммируем текущее количество препятствий с препятствием в новой клетке (grid[newX][newY]
                    if (newObstacles < minObstacles[newX][newY]) { // Если новое количество препятствий меньше, чем ранее записанное в массиве minObstacles
                        minObstacles[newX][newY] = newObstacles; // обновляем значение в этом массиве
                        pq.offer(new int[]{newX, newY, newObstacles}); // и добавляем новую клетку в приоритетную очередь.
                    }
                }
            } // После обработки всех соседей текущей клетки цикл продолжается, пока очередь не опустеет.
        }

        // В конце, если очередь опустела, а цель не достигнута, возвращаем -1, что указывает на отсутствие пути.
        return -1; // Если нет пути
    }
}
