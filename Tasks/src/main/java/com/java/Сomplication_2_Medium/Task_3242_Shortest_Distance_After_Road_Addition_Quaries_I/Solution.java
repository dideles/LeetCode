package com.java.Сomplication_2_Medium.Task_3242_Shortest_Distance_After_Road_Addition_Quaries_I;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

class Solution {

    /**
     * Метод для вычисления кратчайших расстояний между городами после выполнения серии запросов на добавление дорог.
     *
     * @param n       количество городов (узлов в графе)
     * @param queries массив запросов на добавление дорог,
     *                где каждый запрос представляет собой пару (u, v), означающую новую дорогу от города u к городу v.
     * @return        массив целых чисел, представляющий кратчайшие расстояния от города 0 до города n-1
     *                после каждого добавления новой дороги.
     */
    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {
        // Создание пустого графа:
        List<List<Integer>> graph = new ArrayList<>();

        // Инициализация графа:
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }

        // Изначальные дороги
        for (int i = 0; i < n - 1; i++) {
            graph.get(i).add(i + 1);
        }

        // Список для хранения результатов:
        List<Integer> shortestDistances = new ArrayList<>();

        // Обработка запросов:
        for (int[] query : queries) {
            int u = query[0];
            int v = query[1];

            // Добавляем новое ребро
            graph.get(u).add(v);

            // Вычисляем кратчайший путь после добавления нового ребра:
            int shortestPath = bfs(graph, n); // Использование алгоритма поиска в ширину (BFS)
            shortestDistances.add(shortestPath); // Результат каждого BFS-запроса (длина кратчайшего пути) сохраняется в списке.
        } // который затем преобразуется в массив и возвращается.

        // Преобразование списка целых чисел в массив целых чисел
        return shortestDistances.stream().mapToInt(i -> i).toArray();
        // return shortestDistances.stream().mapToInt(Integer::valueOf).toArray();
    }

    /* Поиск кратчайшего пути: */
    /**
     * Реализация алгоритма поиска в ширину (BFS) для нахождения кратчайшего пути от узла 0 до узла n-1.
     *
     * @param graph Граф, представленный списком смежностей.
     * @param n     Количество узлов в графе.
     * @return      Длина кратчайшего пути или -1, если путь отсутствует.
     */
    private int bfs(List<List<Integer>> graph, int n) {
        if (n <= 0) return -1;

        boolean[] visited = new boolean[n];     // Логический массив для отслеживания посещенных городов (узлов)
        // Изначально все элементы равны false, что означает, что ни один узел не посещён.
        int[] distance = new int[n];            // Целочисленный массив для хранения расстояний от стартового узла до других узлов.
        Arrays.fill(distance, Integer.MAX_VALUE); // Все элементы массива distance заполняются максимальным целым значением,
        // которое обозначает бесконечность в контексте кратчайших путей.
        // Это делается потому, что изначально предполагаем, что до всех узлов, кроме исходного, нет пути.

        // Установка нулевого расстояния для стартовой вершины:
        distance[0] = 0; // Расстояние до начального города (начальной вершины) равно нулю
        // Поскольку мы начинаем с первого узла (индекс 0), расстояние до него считается равным нулю.
        // Это отправная точка для дальнейших расчётов.

        // Создание и заполнение очереди:
        LinkedList<Integer> bfsQueue = new LinkedList<>();
        bfsQueue.add(0); // Сначала в неё помещают начальный узел (с индексом 0),
        // поскольку именно с него начинается обработка графа методом BFS.

        while (!bfsQueue.isEmpty()) {

            int current = bfsQueue.poll(); // Извлечение текущего узла
            // Метод poll() удаляет и возвращает элемент из начала очереди.

            visited[current] = true; // Отметка узла как посещенного,
            // чтобы предотвратить многократную обработку одного и того же узла.

            // Обход соседей текущего узла:
            for (int neighbor : graph.get(current)) {

                // Проверка непосещенности соседа:
                if (!visited[neighbor]) { // Если сосед еще не был посещен, то продолжаем обработку.
                    distance[neighbor] = Math.min(distance[neighbor], distance[current] + 1); // Обновление расстояния до соседа
                    bfsQueue.add(neighbor); // Сосед добавляется в конец очереди, чтобы он также был обработан позже.
                }
            }
        }

        // Формирование ответа:
        return distance[n - 1] == Integer.MAX_VALUE ? -1 : distance[n - 1];
        // Возвращаем длину кратчайшего пути или -1, если путь не существует
    }
}